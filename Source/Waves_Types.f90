!STARTOFREGISTRYGENERATEDFILE './Waves_Types.f90'

! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
!*********************************************************************************************************************************
! Waves_Types
!.................................................................................................................................
! This file is part of Waves.
!
! Copyright (C) 2012, 2013 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE Waves_Types
! This module contains all of the user-defined types needed in Waves. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  Waves_InitInputType  =======
  TYPE, PUBLIC :: Waves_InitInputType
    CHARACTER(1024)  :: InputFile 
    CHARACTER(1024)  :: DirRoot 
    CHARACTER(1024)  :: GHWvFile 
    INTEGER(IntKi)  :: UnSum 
    REAL(ReKi)  :: Gravity 
    REAL(ReKi)  :: MSL2SWL 
    REAL(ReKi)  :: WvLowCOff 
    REAL(ReKi)  :: WvHiCOff 
    REAL(ReKi)  :: WaveDir 
    REAL(DbKi)  :: WaveDT 
    REAL(ReKi)  :: WaveHs 
    INTEGER(IntKi)  :: WaveMod 
    CHARACTER(80)  :: WaveModChr 
    LOGICAL  :: WaveNDAmp 
    REAL(ReKi)  :: WavePhase 
    REAL(ReKi)  :: WavePkShp 
    CHARACTER(80)  :: WavePkShpChr 
    INTEGER(IntKi) , DIMENSION(1:2)  :: WaveSeed 
    INTEGER(IntKi)  :: WaveStMod 
    REAL(DbKi)  :: WaveTMax 
    REAL(ReKi)  :: WaveTp 
    REAL(ReKi)  :: WtrDens 
    REAL(ReKi)  :: WtrDpth 
    INTEGER(IntKi)  :: NWaveElev 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveElevxi 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveElevyi 
    INTEGER(IntKi)  :: NWaveKin0 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinxi0 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinyi0 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinzi0 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CurrVxi 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CurrVyi 
    REAL(ReKi)  :: PCurrVxiPz0 
    REAL(ReKi)  :: PCurrVyiPz0 
  END TYPE Waves_InitInputType
! =======================
! =========  Waves_InitOutputType  =======
  TYPE, PUBLIC :: Waves_InitOutputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveElevC0 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc0 
    REAL(ReKi)  :: WaveDir 
    REAL(ReKi)  :: WaveDOmega 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveDynP0 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveElev 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel0 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinzi0 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime 
    REAL(ReKi)  :: RhoXg 
    INTEGER(IntKi)  :: NStepWave 
    INTEGER(IntKi)  :: NStepWave2 
  END TYPE Waves_InitOutputType
! =======================
! =========  Waves_ContinuousStateType  =======
  TYPE, PUBLIC :: Waves_ContinuousStateType
    REAL(ReKi)  :: DummyContState 
  END TYPE Waves_ContinuousStateType
! =======================
! =========  Waves_DiscreteStateType  =======
  TYPE, PUBLIC :: Waves_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState 
  END TYPE Waves_DiscreteStateType
! =======================
! =========  Waves_ConstraintStateType  =======
  TYPE, PUBLIC :: Waves_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState 
  END TYPE Waves_ConstraintStateType
! =======================
! =========  Waves_OtherStateType  =======
  TYPE, PUBLIC :: Waves_OtherStateType
    INTEGER(IntKi)  :: DummyOtherState 
  END TYPE Waves_OtherStateType
! =======================
! =========  Waves_ParameterType  =======
  TYPE, PUBLIC :: Waves_ParameterType
    REAL(DbKi)  :: DT 
  END TYPE Waves_ParameterType
! =======================
! =========  Waves_InputType  =======
  TYPE, PUBLIC :: Waves_InputType
    REAL(ReKi)  :: DummyInput 
  END TYPE Waves_InputType
! =======================
! =========  Waves_OutputType  =======
  TYPE, PUBLIC :: Waves_OutputType
    REAL(ReKi)  :: DummyOutput 
  END TYPE Waves_OutputType
! =======================
CONTAINS
 SUBROUTINE Waves_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(Waves_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%InputFile = SrcInitInputData%InputFile
   DstInitInputData%DirRoot = SrcInitInputData%DirRoot
   DstInitInputData%GHWvFile = SrcInitInputData%GHWvFile
   DstInitInputData%UnSum = SrcInitInputData%UnSum
   DstInitInputData%Gravity = SrcInitInputData%Gravity
   DstInitInputData%MSL2SWL = SrcInitInputData%MSL2SWL
   DstInitInputData%WvLowCOff = SrcInitInputData%WvLowCOff
   DstInitInputData%WvHiCOff = SrcInitInputData%WvHiCOff
   DstInitInputData%WaveDir = SrcInitInputData%WaveDir
   DstInitInputData%WaveDT = SrcInitInputData%WaveDT
   DstInitInputData%WaveHs = SrcInitInputData%WaveHs
   DstInitInputData%WaveMod = SrcInitInputData%WaveMod
   DstInitInputData%WaveModChr = SrcInitInputData%WaveModChr
   DstInitInputData%WaveNDAmp = SrcInitInputData%WaveNDAmp
   DstInitInputData%WavePhase = SrcInitInputData%WavePhase
   DstInitInputData%WavePkShp = SrcInitInputData%WavePkShp
   DstInitInputData%WavePkShpChr = SrcInitInputData%WavePkShpChr
   DstInitInputData%WaveSeed = SrcInitInputData%WaveSeed
   DstInitInputData%WaveStMod = SrcInitInputData%WaveStMod
   DstInitInputData%WaveTMax = SrcInitInputData%WaveTMax
   DstInitInputData%WaveTp = SrcInitInputData%WaveTp
   DstInitInputData%WtrDens = SrcInitInputData%WtrDens
   DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
   DstInitInputData%NWaveElev = SrcInitInputData%NWaveElev
IF (ALLOCATED(SrcInitInputData%WaveElevxi)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveElevxi,1)
   i1_u = UBOUND(SrcInitInputData%WaveElevxi,1)
   IF (.NOT.ALLOCATED(DstInitInputData%WaveElevxi)) THEN 
      ALLOCATE(DstInitInputData%WaveElevxi(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitInput: Error allocating DstInitInputData%WaveElevxi.'
         RETURN
      END IF
   END IF
   DstInitInputData%WaveElevxi = SrcInitInputData%WaveElevxi
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveElevyi)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveElevyi,1)
   i1_u = UBOUND(SrcInitInputData%WaveElevyi,1)
   IF (.NOT.ALLOCATED(DstInitInputData%WaveElevyi)) THEN 
      ALLOCATE(DstInitInputData%WaveElevyi(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitInput: Error allocating DstInitInputData%WaveElevyi.'
         RETURN
      END IF
   END IF
   DstInitInputData%WaveElevyi = SrcInitInputData%WaveElevyi
ENDIF
   DstInitInputData%NWaveKin0 = SrcInitInputData%NWaveKin0
IF (ALLOCATED(SrcInitInputData%WaveKinxi0)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveKinxi0,1)
   i1_u = UBOUND(SrcInitInputData%WaveKinxi0,1)
   IF (.NOT.ALLOCATED(DstInitInputData%WaveKinxi0)) THEN 
      ALLOCATE(DstInitInputData%WaveKinxi0(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitInput: Error allocating DstInitInputData%WaveKinxi0.'
         RETURN
      END IF
   END IF
   DstInitInputData%WaveKinxi0 = SrcInitInputData%WaveKinxi0
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveKinyi0)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveKinyi0,1)
   i1_u = UBOUND(SrcInitInputData%WaveKinyi0,1)
   IF (.NOT.ALLOCATED(DstInitInputData%WaveKinyi0)) THEN 
      ALLOCATE(DstInitInputData%WaveKinyi0(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitInput: Error allocating DstInitInputData%WaveKinyi0.'
         RETURN
      END IF
   END IF
   DstInitInputData%WaveKinyi0 = SrcInitInputData%WaveKinyi0
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveKinzi0)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveKinzi0,1)
   i1_u = UBOUND(SrcInitInputData%WaveKinzi0,1)
   IF (.NOT.ALLOCATED(DstInitInputData%WaveKinzi0)) THEN 
      ALLOCATE(DstInitInputData%WaveKinzi0(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitInput: Error allocating DstInitInputData%WaveKinzi0.'
         RETURN
      END IF
   END IF
   DstInitInputData%WaveKinzi0 = SrcInitInputData%WaveKinzi0
ENDIF
IF (ALLOCATED(SrcInitInputData%CurrVxi)) THEN
   i1_l = LBOUND(SrcInitInputData%CurrVxi,1)
   i1_u = UBOUND(SrcInitInputData%CurrVxi,1)
   IF (.NOT.ALLOCATED(DstInitInputData%CurrVxi)) THEN 
      ALLOCATE(DstInitInputData%CurrVxi(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitInput: Error allocating DstInitInputData%CurrVxi.'
         RETURN
      END IF
   END IF
   DstInitInputData%CurrVxi = SrcInitInputData%CurrVxi
ENDIF
IF (ALLOCATED(SrcInitInputData%CurrVyi)) THEN
   i1_l = LBOUND(SrcInitInputData%CurrVyi,1)
   i1_u = UBOUND(SrcInitInputData%CurrVyi,1)
   IF (.NOT.ALLOCATED(DstInitInputData%CurrVyi)) THEN 
      ALLOCATE(DstInitInputData%CurrVyi(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitInput: Error allocating DstInitInputData%CurrVyi.'
         RETURN
      END IF
   END IF
   DstInitInputData%CurrVyi = SrcInitInputData%CurrVyi
ENDIF
   DstInitInputData%PCurrVxiPz0 = SrcInitInputData%PCurrVxiPz0
   DstInitInputData%PCurrVyiPz0 = SrcInitInputData%PCurrVyiPz0
 END SUBROUTINE Waves_CopyInitInput

 SUBROUTINE Waves_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(Waves_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%WaveElevxi)) THEN
   DEALLOCATE(InitInputData%WaveElevxi)
ENDIF
IF (ALLOCATED(InitInputData%WaveElevyi)) THEN
   DEALLOCATE(InitInputData%WaveElevyi)
ENDIF
IF (ALLOCATED(InitInputData%WaveKinxi0)) THEN
   DEALLOCATE(InitInputData%WaveKinxi0)
ENDIF
IF (ALLOCATED(InitInputData%WaveKinyi0)) THEN
   DEALLOCATE(InitInputData%WaveKinyi0)
ENDIF
IF (ALLOCATED(InitInputData%WaveKinzi0)) THEN
   DEALLOCATE(InitInputData%WaveKinzi0)
ENDIF
IF (ALLOCATED(InitInputData%CurrVxi)) THEN
   DEALLOCATE(InitInputData%CurrVxi)
ENDIF
IF (ALLOCATED(InitInputData%CurrVyi)) THEN
   DEALLOCATE(InitInputData%CurrVyi)
ENDIF
 END SUBROUTINE Waves_DestroyInitInput

 SUBROUTINE Waves_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! UnSum
  Re_BufSz   = Re_BufSz   + 1  ! Gravity
  Re_BufSz   = Re_BufSz   + 1  ! MSL2SWL
  Re_BufSz   = Re_BufSz   + 1  ! WvLowCOff
  Re_BufSz   = Re_BufSz   + 1  ! WvHiCOff
  Re_BufSz   = Re_BufSz   + 1  ! WaveDir
  Db_BufSz   = Db_BufSz   + 1  ! WaveDT
  Re_BufSz   = Re_BufSz   + 1  ! WaveHs
  Int_BufSz  = Int_BufSz  + 1  ! WaveMod
  Re_BufSz   = Re_BufSz   + 1  ! WavePhase
  Re_BufSz   = Re_BufSz   + 1  ! WavePkShp
  Int_BufSz   = Int_BufSz   + SIZE( InData%WaveSeed )  ! WaveSeed 
  Int_BufSz  = Int_BufSz  + 1  ! WaveStMod
  Db_BufSz   = Db_BufSz   + 1  ! WaveTMax
  Re_BufSz   = Re_BufSz   + 1  ! WaveTp
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
  Int_BufSz  = Int_BufSz  + 1  ! NWaveElev
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveElevxi )  ! WaveElevxi 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveElevyi )  ! WaveElevyi 
  Int_BufSz  = Int_BufSz  + 1  ! NWaveKin0
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveKinxi0 )  ! WaveKinxi0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveKinyi0 )  ! WaveKinyi0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveKinzi0 )  ! WaveKinzi0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%CurrVxi )  ! CurrVxi 
  Re_BufSz    = Re_BufSz    + SIZE( InData%CurrVyi )  ! CurrVyi 
  Re_BufSz   = Re_BufSz   + 1  ! PCurrVxiPz0
  Re_BufSz   = Re_BufSz   + 1  ! PCurrVyiPz0
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnSum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MSL2SWL )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WvLowCOff )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WvHiCOff )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WaveDir )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%WaveDT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WaveHs )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%WaveMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WavePhase )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WavePkShp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%WaveSeed))-1 ) = PACK(InData%WaveSeed ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%WaveSeed)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%WaveStMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%WaveTMax )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WaveTp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDpth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NWaveElev )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%WaveElevxi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveElevxi))-1 ) =  PACK(InData%WaveElevxi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveElevxi)
  ENDIF
  IF ( ALLOCATED(InData%WaveElevyi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveElevyi))-1 ) =  PACK(InData%WaveElevyi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveElevyi)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NWaveKin0 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%WaveKinxi0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveKinxi0))-1 ) =  PACK(InData%WaveKinxi0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveKinxi0)
  ENDIF
  IF ( ALLOCATED(InData%WaveKinyi0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveKinyi0))-1 ) =  PACK(InData%WaveKinyi0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveKinyi0)
  ENDIF
  IF ( ALLOCATED(InData%WaveKinzi0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveKinzi0))-1 ) =  PACK(InData%WaveKinzi0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveKinzi0)
  ENDIF
  IF ( ALLOCATED(InData%CurrVxi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CurrVxi))-1 ) =  PACK(InData%CurrVxi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CurrVxi)
  ENDIF
  IF ( ALLOCATED(InData%CurrVyi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CurrVyi))-1 ) =  PACK(InData%CurrVyi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CurrVyi)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PCurrVxiPz0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PCurrVyiPz0 )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Waves_PackInitInput

 SUBROUTINE Waves_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%UnSum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MSL2SWL = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WvLowCOff = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WvHiCOff = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WaveDir = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WaveDT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%WaveHs = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WaveMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%WavePhase = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WavePkShp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%WaveSeed,1))); mask1 = .TRUE.
  OutData%WaveSeed = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%WaveSeed))-1 ),mask1,OutData%WaveSeed)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%WaveSeed)
  OutData%WaveStMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%WaveTMax = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%WaveTp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDpth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NWaveElev = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%WaveElevxi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveElevxi,1))); mask1 = .TRUE.
    OutData%WaveElevxi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveElevxi))-1 ),mask1,OutData%WaveElevxi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveElevxi)
  ENDIF
  IF ( ALLOCATED(OutData%WaveElevyi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveElevyi,1))); mask1 = .TRUE.
    OutData%WaveElevyi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveElevyi))-1 ),mask1,OutData%WaveElevyi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveElevyi)
  ENDIF
  OutData%NWaveKin0 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%WaveKinxi0) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveKinxi0,1))); mask1 = .TRUE.
    OutData%WaveKinxi0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveKinxi0))-1 ),mask1,OutData%WaveKinxi0)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveKinxi0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveKinyi0) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveKinyi0,1))); mask1 = .TRUE.
    OutData%WaveKinyi0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveKinyi0))-1 ),mask1,OutData%WaveKinyi0)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveKinyi0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveKinzi0) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveKinzi0,1))); mask1 = .TRUE.
    OutData%WaveKinzi0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveKinzi0))-1 ),mask1,OutData%WaveKinzi0)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveKinzi0)
  ENDIF
  IF ( ALLOCATED(OutData%CurrVxi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CurrVxi,1))); mask1 = .TRUE.
    OutData%CurrVxi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CurrVxi))-1 ),mask1,OutData%CurrVxi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CurrVxi)
  ENDIF
  IF ( ALLOCATED(OutData%CurrVyi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CurrVyi,1))); mask1 = .TRUE.
    OutData%CurrVyi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CurrVyi))-1 ),mask1,OutData%CurrVyi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CurrVyi)
  ENDIF
  OutData%PCurrVxiPz0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PCurrVyiPz0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPackInitInput

 SUBROUTINE Waves_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(Waves_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WaveElevC0)) THEN
   i1_l = LBOUND(SrcInitOutputData%WaveElevC0,1)
   i1_u = UBOUND(SrcInitOutputData%WaveElevC0,1)
   i2_l = LBOUND(SrcInitOutputData%WaveElevC0,2)
   i2_u = UBOUND(SrcInitOutputData%WaveElevC0,2)
   IF (.NOT.ALLOCATED(DstInitOutputData%WaveElevC0)) THEN 
      ALLOCATE(DstInitOutputData%WaveElevC0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitOutput: Error allocating DstInitOutputData%WaveElevC0.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WaveElevC0 = SrcInitOutputData%WaveElevC0
ENDIF
IF (ALLOCATED(SrcInitOutputData%WaveAcc0)) THEN
   i1_l = LBOUND(SrcInitOutputData%WaveAcc0,1)
   i1_u = UBOUND(SrcInitOutputData%WaveAcc0,1)
   i2_l = LBOUND(SrcInitOutputData%WaveAcc0,2)
   i2_u = UBOUND(SrcInitOutputData%WaveAcc0,2)
   i3_l = LBOUND(SrcInitOutputData%WaveAcc0,3)
   i3_u = UBOUND(SrcInitOutputData%WaveAcc0,3)
   IF (.NOT.ALLOCATED(DstInitOutputData%WaveAcc0)) THEN 
      ALLOCATE(DstInitOutputData%WaveAcc0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitOutput: Error allocating DstInitOutputData%WaveAcc0.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WaveAcc0 = SrcInitOutputData%WaveAcc0
ENDIF
   DstInitOutputData%WaveDir = SrcInitOutputData%WaveDir
   DstInitOutputData%WaveDOmega = SrcInitOutputData%WaveDOmega
IF (ALLOCATED(SrcInitOutputData%WaveDynP0)) THEN
   i1_l = LBOUND(SrcInitOutputData%WaveDynP0,1)
   i1_u = UBOUND(SrcInitOutputData%WaveDynP0,1)
   i2_l = LBOUND(SrcInitOutputData%WaveDynP0,2)
   i2_u = UBOUND(SrcInitOutputData%WaveDynP0,2)
   IF (.NOT.ALLOCATED(DstInitOutputData%WaveDynP0)) THEN 
      ALLOCATE(DstInitOutputData%WaveDynP0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitOutput: Error allocating DstInitOutputData%WaveDynP0.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WaveDynP0 = SrcInitOutputData%WaveDynP0
ENDIF
IF (ALLOCATED(SrcInitOutputData%WaveElev)) THEN
   i1_l = LBOUND(SrcInitOutputData%WaveElev,1)
   i1_u = UBOUND(SrcInitOutputData%WaveElev,1)
   i2_l = LBOUND(SrcInitOutputData%WaveElev,2)
   i2_u = UBOUND(SrcInitOutputData%WaveElev,2)
   IF (.NOT.ALLOCATED(DstInitOutputData%WaveElev)) THEN 
      ALLOCATE(DstInitOutputData%WaveElev(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitOutput: Error allocating DstInitOutputData%WaveElev.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WaveElev = SrcInitOutputData%WaveElev
ENDIF
IF (ALLOCATED(SrcInitOutputData%WaveVel0)) THEN
   i1_l = LBOUND(SrcInitOutputData%WaveVel0,1)
   i1_u = UBOUND(SrcInitOutputData%WaveVel0,1)
   i2_l = LBOUND(SrcInitOutputData%WaveVel0,2)
   i2_u = UBOUND(SrcInitOutputData%WaveVel0,2)
   i3_l = LBOUND(SrcInitOutputData%WaveVel0,3)
   i3_u = UBOUND(SrcInitOutputData%WaveVel0,3)
   IF (.NOT.ALLOCATED(DstInitOutputData%WaveVel0)) THEN 
      ALLOCATE(DstInitOutputData%WaveVel0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitOutput: Error allocating DstInitOutputData%WaveVel0.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WaveVel0 = SrcInitOutputData%WaveVel0
ENDIF
IF (ALLOCATED(SrcInitOutputData%WaveKinzi0)) THEN
   i1_l = LBOUND(SrcInitOutputData%WaveKinzi0,1)
   i1_u = UBOUND(SrcInitOutputData%WaveKinzi0,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%WaveKinzi0)) THEN 
      ALLOCATE(DstInitOutputData%WaveKinzi0(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitOutput: Error allocating DstInitOutputData%WaveKinzi0.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WaveKinzi0 = SrcInitOutputData%WaveKinzi0
ENDIF
IF (ALLOCATED(SrcInitOutputData%WaveTime)) THEN
   i1_l = LBOUND(SrcInitOutputData%WaveTime,1)
   i1_u = UBOUND(SrcInitOutputData%WaveTime,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%WaveTime)) THEN 
      ALLOCATE(DstInitOutputData%WaveTime(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'Waves_CopyInitOutput: Error allocating DstInitOutputData%WaveTime.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WaveTime = SrcInitOutputData%WaveTime
ENDIF
   DstInitOutputData%RhoXg = SrcInitOutputData%RhoXg
   DstInitOutputData%NStepWave = SrcInitOutputData%NStepWave
   DstInitOutputData%NStepWave2 = SrcInitOutputData%NStepWave2
 END SUBROUTINE Waves_CopyInitOutput

 SUBROUTINE Waves_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(Waves_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WaveElevC0)) THEN
   DEALLOCATE(InitOutputData%WaveElevC0)
ENDIF
IF (ALLOCATED(InitOutputData%WaveAcc0)) THEN
   DEALLOCATE(InitOutputData%WaveAcc0)
ENDIF
IF (ALLOCATED(InitOutputData%WaveDynP0)) THEN
   DEALLOCATE(InitOutputData%WaveDynP0)
ENDIF
IF (ALLOCATED(InitOutputData%WaveElev)) THEN
   DEALLOCATE(InitOutputData%WaveElev)
ENDIF
IF (ALLOCATED(InitOutputData%WaveVel0)) THEN
   DEALLOCATE(InitOutputData%WaveVel0)
ENDIF
IF (ALLOCATED(InitOutputData%WaveKinzi0)) THEN
   DEALLOCATE(InitOutputData%WaveKinzi0)
ENDIF
IF (ALLOCATED(InitOutputData%WaveTime)) THEN
   DEALLOCATE(InitOutputData%WaveTime)
ENDIF
 END SUBROUTINE Waves_DestroyInitOutput

 SUBROUTINE Waves_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveElevC0 )  ! WaveElevC0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveAcc0 )  ! WaveAcc0 
  Re_BufSz   = Re_BufSz   + 1  ! WaveDir
  Re_BufSz   = Re_BufSz   + 1  ! WaveDOmega
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveDynP0 )  ! WaveDynP0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveElev )  ! WaveElev 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveVel0 )  ! WaveVel0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveKinzi0 )  ! WaveKinzi0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WaveTime )  ! WaveTime 
  Re_BufSz   = Re_BufSz   + 1  ! RhoXg
  Int_BufSz  = Int_BufSz  + 1  ! NStepWave
  Int_BufSz  = Int_BufSz  + 1  ! NStepWave2
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%WaveElevC0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveElevC0))-1 ) =  PACK(InData%WaveElevC0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveElevC0)
  ENDIF
  IF ( ALLOCATED(InData%WaveAcc0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveAcc0))-1 ) =  PACK(InData%WaveAcc0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveAcc0)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WaveDir )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WaveDOmega )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%WaveDynP0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveDynP0))-1 ) =  PACK(InData%WaveDynP0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveDynP0)
  ENDIF
  IF ( ALLOCATED(InData%WaveElev) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveElev))-1 ) =  PACK(InData%WaveElev ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveElev)
  ENDIF
  IF ( ALLOCATED(InData%WaveVel0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveVel0))-1 ) =  PACK(InData%WaveVel0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveVel0)
  ENDIF
  IF ( ALLOCATED(InData%WaveKinzi0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveKinzi0))-1 ) =  PACK(InData%WaveKinzi0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveKinzi0)
  ENDIF
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveTime))-1 ) =  PACK(InData%WaveTime ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveTime)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%RhoXg )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NStepWave )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NStepWave2 )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE Waves_PackInitOutput

 SUBROUTINE Waves_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%WaveElevC0) ) THEN
  ALLOCATE(mask2(SIZE(OutData%WaveElevC0,1),SIZE(OutData%WaveElevC0,2))); mask2 = .TRUE.
    OutData%WaveElevC0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveElevC0))-1 ),mask2,OutData%WaveElevC0)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveElevC0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveAcc0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveAcc0,1),SIZE(OutData%WaveAcc0,2),SIZE(OutData%WaveAcc0,3))); mask3 = .TRUE.
    OutData%WaveAcc0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveAcc0))-1 ),mask3,OutData%WaveAcc0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveAcc0)
  ENDIF
  OutData%WaveDir = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WaveDOmega = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%WaveDynP0) ) THEN
  ALLOCATE(mask2(SIZE(OutData%WaveDynP0,1),SIZE(OutData%WaveDynP0,2))); mask2 = .TRUE.
    OutData%WaveDynP0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveDynP0))-1 ),mask2,OutData%WaveDynP0)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveDynP0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveElev) ) THEN
  ALLOCATE(mask2(SIZE(OutData%WaveElev,1),SIZE(OutData%WaveElev,2))); mask2 = .TRUE.
    OutData%WaveElev = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveElev))-1 ),mask2,OutData%WaveElev)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveElev)
  ENDIF
  IF ( ALLOCATED(OutData%WaveVel0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveVel0,1),SIZE(OutData%WaveVel0,2),SIZE(OutData%WaveVel0,3))); mask3 = .TRUE.
    OutData%WaveVel0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveVel0))-1 ),mask3,OutData%WaveVel0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveVel0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveKinzi0) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveKinzi0,1))); mask1 = .TRUE.
    OutData%WaveKinzi0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveKinzi0))-1 ),mask1,OutData%WaveKinzi0)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveKinzi0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveTime) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveTime,1))); mask1 = .TRUE.
    OutData%WaveTime = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveTime))-1 ),mask1,OutData%WaveTime)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveTime)
  ENDIF
  OutData%RhoXg = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NStepWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NStepWave2 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPackInitOutput

 SUBROUTINE Waves_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(Waves_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE Waves_CopyContState

 SUBROUTINE Waves_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(Waves_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Waves_DestroyContState

 SUBROUTINE Waves_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Waves_PackContState

 SUBROUTINE Waves_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPackContState

 SUBROUTINE Waves_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(Waves_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE Waves_CopyDiscState

 SUBROUTINE Waves_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(Waves_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Waves_DestroyDiscState

 SUBROUTINE Waves_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Waves_PackDiscState

 SUBROUTINE Waves_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPackDiscState

 SUBROUTINE Waves_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(Waves_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE Waves_CopyConstrState

 SUBROUTINE Waves_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(Waves_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Waves_DestroyConstrState

 SUBROUTINE Waves_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Waves_PackConstrState

 SUBROUTINE Waves_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPackConstrState

 SUBROUTINE Waves_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(Waves_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOtherStateData%DummyOtherState = SrcOtherStateData%DummyOtherState
 END SUBROUTINE Waves_CopyOtherState

 SUBROUTINE Waves_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(Waves_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Waves_DestroyOtherState

 SUBROUTINE Waves_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! DummyOtherState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DummyOtherState )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE Waves_PackOtherState

 SUBROUTINE Waves_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyOtherState = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPackOtherState

 SUBROUTINE Waves_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(Waves_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%DT = SrcParamData%DT
 END SUBROUTINE Waves_CopyParam

 SUBROUTINE Waves_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(Waves_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Waves_DestroyParam

 SUBROUTINE Waves_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE Waves_PackParam

 SUBROUTINE Waves_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPackParam

 SUBROUTINE Waves_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(Waves_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInputData%DummyInput = SrcInputData%DummyInput
 END SUBROUTINE Waves_CopyInput

 SUBROUTINE Waves_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(Waves_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Waves_DestroyInput

 SUBROUTINE Waves_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyInput
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyInput )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Waves_PackInput

 SUBROUTINE Waves_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyInput = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPackInput

 SUBROUTINE Waves_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(Waves_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOutputData%DummyOutput = SrcOutputData%DummyOutput
 END SUBROUTINE Waves_CopyOutput

 SUBROUTINE Waves_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(Waves_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Waves_DestroyOutput

 SUBROUTINE Waves_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyOutput
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyOutput )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Waves_PackOutput

 SUBROUTINE Waves_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyOutput = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPackOutput

 SUBROUTINE Waves_Pack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg, &
                     SizeOnly )
  TYPE(Waves_InputType),           INTENT(INOUT) :: InData
  TYPE(Waves_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(Waves_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(Waves_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(Waves_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(Waves_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(Waves_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(  OUT) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(  OUT) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,  INTENT(  OUT) :: Int_RetAry(:)
  INTEGER(IntKi),               INTENT(  OUT) :: ErrStat
  CHARACTER(*),                 INTENT(  OUT) :: ErrMsg
  LOGICAL, OPTIONAL,            INTENT(IN   ) :: SizeOnly
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  LOGICAL                                :: OnlySize ! if present and true, do not pack, just allocate buffers
    ! Executable statements
  ErrStat = ErrID_None
  ErrMsg  = ""
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred  = Re_Xferred - 1
  Db_Xferred  = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
  IF ( ALLOCATED( Re_RetAry ) ) DEALLOCATE( Re_RetAry ) ;
  IF ( Re_Xferred .GT. 0) ALLOCATE( Re_RetAry( Re_Xferred ) ) ;
  IF ( ALLOCATED( Db_RetAry ) ) DEALLOCATE( Db_RetAry ) ;
  IF ( Db_Xferred .GT. 0) ALLOCATE( Db_RetAry( Db_Xferred ) ) ;
  IF ( ALLOCATED( Int_RetAry ) ) DEALLOCATE( Int_RetAry ) ;
  IF ( Int_Xferred .GT. 0) ALLOCATE( Int_RetAry( Int_Xferred ) ) ;
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred   = Re_Xferred - 1
  Db_Xferred   = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
 END SUBROUTINE Waves_Pack

 SUBROUTINE Waves_UnPack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg )
  TYPE(Waves_InputType),           INTENT(INOUT) :: InData
  TYPE(Waves_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(Waves_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(Waves_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(Waves_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(Waves_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(Waves_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(IN   ) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(IN   ) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,   INTENT(IN   ) :: Int_RetAry(:)
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! UnPack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL Waves_UnPackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL Waves_UnPackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL Waves_UnPackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL Waves_UnPackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL Waves_UnPackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL Waves_UnPackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL Waves_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL Waves_UnPackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Waves_UnPack


 SUBROUTINE Waves_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Waves_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(Waves_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in Waves_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  u_out%DummyInput = u(1)%DummyInput
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = -(u(1)%DummyInput - u(2)%DummyInput)/t(2)
  u_out%DummyInput = u(1)%DummyInput + b0 * t_out
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = (t(3)**2*(u(1)%DummyInput - u(2)%DummyInput) + t(2)**2*(-u(1)%DummyInput + u(3)%DummyInput))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%DummyInput + t(3)*u(2)%DummyInput - t(2)*u(3)%DummyInput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%DummyInput = u(1)%DummyInput + b0 * t_out + c0 * t_out**2
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in Waves_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE Waves_Input_ExtrapInterp


 SUBROUTINE Waves_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Waves_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(Waves_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in Waves_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  u_out%DummyOutput = u(1)%DummyOutput
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = -(u(1)%DummyOutput - u(2)%DummyOutput)/t(2)
  u_out%DummyOutput = u(1)%DummyOutput + b0 * t_out
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Waves_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = (t(3)**2*(u(1)%DummyOutput - u(2)%DummyOutput) + t(2)**2*(-u(1)%DummyOutput + u(3)%DummyOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%DummyOutput + t(3)*u(2)%DummyOutput - t(2)*u(3)%DummyOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%DummyOutput = u(1)%DummyOutput + b0 * t_out + c0 * t_out**2
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in Waves_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE Waves_Output_ExtrapInterp

END MODULE Waves_Types
!ENDOFREGISTRYGENERATEDFILE
